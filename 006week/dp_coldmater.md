# 동적 계획법

## 동적계획법의 정의

- 복잡한 문제를 그보다 단순한 하위 문제로 나눠서 푸는 방식
- 재귀적인 특성으로 해결할 수 있음

> [!NOTE]
> 분할정복과의 차이점
>
> - 공통: 큰 문제를 하위 문제로 나눠, 하위 문제의 최적의 해법을 합쳐 올리는 방식임에는 동일
> - 차이: 분할정복은 반복되지 않는 하위 문제를 다루는 데 비해, 동적계획법은 반복되는 하위문제를 활용 -> 캐싱(메모이제이션)

## 동적계획법을 적용할 수 있는 문제의 특징

특정 제약사항(무게 등)이 있을 때 최적(최대, 최소 등)의 해를 구하는 방식의 패턴이 자주 등장한다.

- 최적 부분 구조, optimal substructure
  - 최적부분구조란, 부분 문제의 최적해를 단순히 합치는 것으로 전체 문제의 최적해가 될 수 있는 구조를 말한다.
  - [서울 -> 대구 -> 부산 예제](https://namu.wiki/w/%EA%B7%B8%EB%A6%AC%EB%94%94%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98#%EC%B5%9C%EC%A0%81%20%EB%B6%80%EB%B6%84%20%EA%B5%AC%EC%A1%B0)
    - 전체문제: 서울 -> 부산
    - 부분문제: 서울 -> 대구, 대구 -> 부산
    - 서울 -> 대구 의 최적해와 대구 -> 부산의 최적해의 합이 결국 전체 문제의 해
  - LeetCode Stock 문제 (가격하락시 무조건 판매, 상승시 보류)
    - 전체문제: 전체 시간에서의 최대 수익
    - 부분문제: 상승구간, 하락구간
    - 상승구간에서 보류, 하락구간에서는 판매하는 부분에서의 최적 전략이 전체 문제의 해
- 하위 문제의 반복 (동일한 평가를 반복 사용 가능해야 함)
  - 재귀함수에 동일한 매개변수가 반복적으로 전달

> [!NOTE]
> 최적부분구조란?

> [!NOTE]
> 최적부분구조는 그리디(Greedy) 문제에도 동일하게 적용된다.

### 동적계획법을 활용할 수 있는 대표적인 문제들

- 벨만 방정식(강화학습)
- 다익스트라 알고리즘 (최단경로)
- 피보나치 수열
- 배낭문제(knapsack)
  - 가방: 무게
  - 물건들: 무게와 가격
  - 가방에 담아 최대 이익을 내려면?
- LCS (가장 긴 공통 부분수열, Longest Common Subsequence)
- 와일드카드 패턴 매칭
- 부분집합 합
- 레벤슈타인 거리

## 메모이제이션

반복되는 하위 문제에서 동일한 평가(연산)이 반복된다면, 이를 별도의 자료구조에 저장해두고 재활용하는 방식을 의미한다. 동적 계획법으로 푸는 문제의 효율을 높이는 방법이다.

### 피보나치 수열과 메모이제이션

피보나치 수열에서 n 번째 항을 가져오는 함수를 구성한다고 생각해보자.

### 동적 계획법과 메모이제이션

> [!NOTE]
> 동적계획법과 메모이제이션이 같은 것이라고 일반적으로 생각되지만, 그렇지는 않다. 동적계획법은 위 정의와 같이 복잡한 문제를 그보다 단순하며 반복되는 하위문제로 나눠서 푸는 방식을 의미한다. 이 과정에서 동일한 연산이 발생하면 이를 반복하지 않기 위해 캐싱(메모이제이션 등)을 하여 최적화를 하는 것이다. 메모이제이션은 동적계획법 외의 다른 알고리즘에서도 활용한다.

## 타뷸레이션

모든 DP 문제는 그리드를 그리는 것에서부터 시작한다고 해도 과언이 아니다. DP 에서 그리드란, 주어 두 가지 변수(제한과 최적대상) 를 가지고 표를 구성한 것이다.

### 피보나치 수열과 타뷸레이션

피보나치 수열 문제를 재귀함수를 활용(n 부터 시작)하여 풀 수도 있지만, for 문을 활용하여 낮은 n 부터 순차적으로 증가시켜가며 연산을 수행할 수도 있다. 이렇게 하면 필요한 연산(메모이제이션이 모든 연산 결과를 기억했던 것에 비해)만을 수행하며 진행할 수 있다.

```text
n    f(n)    f(n-1)    f(n-2)
1       1         -         -
2       1         1         -
3       2         1         1
4       3         2         1
5       5         2         2
6       8       ...       ...
```

## top-down 방식과 bottom-up 방식

DP 문제를 푸는 방식에는 크게 두 가지 접근법이 있다. 부분문제의 평가 순서를 결정하는 방식에 따라 다음과 같이 두 가지로 분류할 수 있다.

### top-down

위 피보나치 문제에서 $f(6)$ 을 계산해야 할 때, a: $f(5)$ 와 b: $f(4)$ 를 호출하여 더한 뒤 응답해야 한다. c: $f(5)$ 는 다시 d: $f(3)$ 과 e: $f(4)$ 를 호출한다. 이 때, b 에서 호출되었던 f(4) 가 e 에서 다시 호출되고 있음을 확인할 수 있다. 이 연산은 f(3) 과 f(2) 를 더하는 연산이며, 중복연산될 필요가 없다. 특정 자료구조에 저장해놓고, 반복 호출될 때 꺼내쓰기만 하면 된다.

장점은 하위 문제를 평가하는 최적의 순서를 알 필요가 없다는 것이다.

### bottom-up

작은 부분문제를 먼저 평가한다. DP 는 복잡한 큰 문제를 작은 부분문제로 쪼개서 평가한 뒤, 합쳐서 큰 문제의 답이 되길 원하는 방식이다. 따라서, 작은 문제를 먼저 평가하게 되면 작은 문제의 평가 결과가 큰 문제에서 어떻게 활용할지 결정할 수 있다. 이는 DP 문제를 풀어나가는 방식에서 '최적의 순서'를 고려한 방법이 될 수 있다.

top-down 방식에서 '최적의 순서를 고려할 필요가 없다.'라는게 장점이었지만, 말 그대로 최적의 순서가 아니게 되기에 효율적이지 못한 부분이 있었다. bottom-up 방식에서는 '최적의 순서'가 문제를 푸는 방식에 반영된다.

f(1), f(2) 는 결정되어있으며, f(3) 은 f(1) 과 f(2) 를 합한다. 그 다음은 f(4). f(4) 는 f(3) 과 f(2) 를 더한다. 이는 바로 전 단계에서 계산된 결과를 가지고 있다. 그 다음은 f(5), 역시 f(4) 와 f(3) 은 바로 전 단계에서 계산된 결과다. 매 인덱스마다 전단계에서 계산된 결과와, 전전단계에서 계산된 결과만 가지고 있다면 답을 알 수 있다.

이 방식을 그리드로 표현해보면 다음과 같다.

아래 그리드에서 f(6)을 구하는 방식은 어떻게 될까?

```text
   n |   1   2   3   4   5  6  7  8
-----+---------------------------------
f(n) |   1   1   2   3   5  ?
     |
c_a  |   -   1   1   2   3  5
     |
c_b  |   1   1   1   1   2  3
```

위 그리드가 작동하는 방식은 아래 그림과 함께 설명할 수 있다. 아래 3개의 화살표가 있다.
그리드의 x 축과 y 축에 해당하는 값을 설정한 뒤 반복문을 돌며 `<A>`, `<B>`, `<C>` 순서로 진행해주면 된다.
이 과정이 순차적으로 반복되며 (최적부분구조?) 결과적으로 해를 찾게 된다.

```text
   n |   1   2   3   4   5  6  7  8
-----+---------------------------------
f(n) |   1   1   2   3   5  ?
     |                    ↘<A>
c_a  |   -   1   1   2   3  5
     |                    ↘<B>
c_b  |   1   1   1   1   2  3 →<C> f(6) 으로 정답
```

DP 문제는 문제의 최적부분구조를 파악하여 위와 같이 Grid 를 구성하고, 하위문제가 상위문제로 전달되는 방식을 고안(화살표)한 뒤, 이를 코드로 옮겨 해결하면 된다.

## 배낭(knapsack)문제 DP 로 해결해보기

### 문제

크기가 15인 가방에 물건을 최대한 많이 담아 가장 높은 가격을 만들고 싶다.
물건의 종류과 크기 및 가격은 다음과 같다.

- 책(크기: 4, 가격: 2)
- 꽃(크기: 5, 가격: 5)
- 삽(크기:11, 가격: 6)

### 그냥 풀기 (Brute force)

모든 물건을 한 번씩 넣어본다.

1. 모두 넣지 않는 경우가 있다.
2. 책만 넣음
3. 꽃만 넣음
4. 삽만 넣음
5. (책만 넣은 (2.) 상태에서) 꽃을 넣음
6. (책만 넣은 (2.) 상태에서) 삽을 넣음
7. (꽃만 넣은 (3.) 상태에서) 삽을 넣음
8. 모두 다 넣음

각각의 물건을 넣거나 넣지 않을 수 있기 때문에 $2^{3}$ 의 경우의 수에 대해 고려해야 한다. 물건이 3개밖에 없는 케이스이기 때문에 간단해보이지만, 물건이 한개씩 추가될 때마다 경우의 수는 2가지씩 늘어난다. 그렇게 n 개의 물건에 대해 시간복잡도는 $2^n$ 이 된다.

더 나은 풀이 방법이 필요하다. -> DP

> [!NOTE]
> 여기서 각 물건을 포함하거나 포함하지 않는다는 것을 전제로 재귀함수 호출 + 메모이제이션으로 문제에 접근할 수도있겠다.

### 왜 DP 가 적합한가?

질문0: 단순한 하위문제란?
질문1: 이 문제에서 최적부분구조란?
질문2: 이 문제에서 반복되는 하위문제란?

-> 모르겠으면 일단 그리드를 그려보자.

### 그리드 그리기

```text
bagSize |  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
book    |              a
flower  |                                   b
shovel  |                       c
```

각 알파벳의 의미는 다음과 같다.

- a: 크기 5인 가방에 책을 담을 수 있다면 그 때의 최대가격
- b: 크기 12인 가방에 책이나 꽃, 또는 둘 다 담아 만들 수 있는 최대가격
- c: 크기 8인 가방에 책, 꽃, 삽 중 일부, 또는 전부를 담아 만들 수 있는 최대가격

#### 단순하게 생각하기

(이걸 어떻게 단순하게 생각해낼 수 있는지는 정말 의문이지만)
먼저, 단순한 하위문제로 쪼갠다는 의미부터 생각해보자. 어떻게 할 수 있을까? 최대한 단순하게 생각해보는 것이다.
현재, 크기 15인 가방에 3가지의 물건을 담는 경우를 생각하고 있다. 이를 단순화해서 생각해다는 것은 다음과 같다.

- 가방의 크기가 1부터 시작한다고 생각해보자.
- 물건은 1개부터 담아보자.

```text
bagSize |  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
book    |>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
flower  |>>>>>>>>>>>>>>>> ...
shovel  |
```

#### 일단은 채워보자

크기가 1인 가방에 book 은 담을 수 없다.

```text
bagSize |  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
book    |  0
flower  |
shovel  |
```

가방의 크기를 늘려가다 보면 담을 수 있는 기회가 온다. (책은 크기가 4, 가격은 2였다.)

```text
bagSize |  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
book    |  0  0  0  2
flower  |
shovel  |
```

책은 1개밖에 없으므로, book 행은 모두 2로 채워진다고 볼 수 있다.

```text
bagSize |  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
book    |  0  0  0  2  2  2  2  2  2  2  2  2  2  2  2
flower  |
shovel  |
```

가방 크기 4에서 flower 는 채울 수 없지만, 이전 행의 이력에서 book 을 넣는 케이스가 있으므로, 이를 취한다.

```text
bagSize |  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
book    |  0  0  0  2 (2) 2  2  2  2  2  2  2  2  2  2
flower  |  0  0  0  2*
shovel  |
```

그 다음, flower 를 채워보자. 주의할 것은, 이미 book 이 채워진 경우가 있으니 이를 고려해서 채울 필요가 있다. 채우다 보면, 크기가 5인 경우를 맞닥뜨리게 된다. (어차피 1~4 크기에서는 꽃을 넣을 수도 없었다.)

```text
bagSize |  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
book    |  0  0  0  2 (2) 2  2  2  2  2  2  2  2  2  2
flower  |  0  0  0  2  ?
shovel  |
```

이 때 고민해야 한다. 가방에 책을 그대로 둘 지, 꽃을 대신 채울지. 꽃을 채우는 것이 이득이다. 괄호 표시(`(2)`)된 부분과 비교하여 꽃을 넣었을 때의 이득(5)가 더 크므로 바꾸는 것이다.

```text
bagSize |  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
book    |  0  0  0  2 (2) 2  2  2  2  2  2  2  2  2  2
flower  |  0  0  0  2  5*
shovel  |
```

다시 계속 채워 나간다. 매커니즘은 같다. 가방의 크기가 8 이하에서는 꽃, 책 둘 중 하나만을 담아야 하고, 언제나 꽃을 담는 선택이 최선이다.

```text
bagSize |  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
book    |  0  0  0  2  2  2  2  2  2  2  2  2  2  2  2
flower  |  0  0  0  2  5  5* 5* 5*
shovel  |
```

가방 크기가 9가 되었다. 이제 꽃과 책 모두 담을 수 있게 되었다. 이 때, 계산 결과는 어떻게 얻어진 것일까?

먼저, flower 는 크기가 5이다. 이걸 가방에 넣고 나면, 4만큼의 크기가 남는다. 이전 행(book)에서 4에 해당하는 값이 2였다.
아직 많은 행을 진행하지 않아서 최댓값이라는 표현을 쓰기가 어색하지만, 이전에 했던 시행 중에 크기가 4인 가방에 가장 큰 가치를 넣은 케이스가 2인 것이다.

```text
bagSize |  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
book    |  0  0  0 (2) 2  2  2  2  2  2  2  2  2  2  2
flower  |  0  0  0  2  5  5  5  5  7*
shovel  |
```

그 다음에도 매커니즘은 동일하다. 10의 가방에 꽃(크기:5)를 넣었을 때 남은 크기의 가방(5)에 담을 수 있는 최대 가치는 2였다. 따라서 7 이 들어가는 것이 맞다.

```text
bagSize |  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
book    |  0  0  0  2 (2) 2  2  2  2  2  2  2  2  2  2
flower  |  0  0  0  2  5  5  5  5  7  7*
shovel  |
```

flower 의 나머지 열도 모두 채워준다.

```text
bagSize |  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
book    |  0  0  0  2 (2) 2  2  2  2  2  2  2  2  2  2
flower  |  0  0  0  2  5  5  5  5  7  7  7  7  7  7  7
shovel  |
```

이제 shovel(크기:11) 의 차례다. shovel 의 크기보다 작은 가방은 패스한다.

가방 크기 11에서 고민해야 한다. 무엇을 넣는게 가장 큰 이득일까?
삽만 하나 넣을 수 있고 이 때의 가치는 6이다. 이전 이력이 훨씬 낫다.
따라서, 삽을 넣는 것이 아닌 이전 구성을 그대로 유지한다. 따라서 7이 들어간다.

```text
bagSize |  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
book    |  0  0  0  2  2  2  2  2  2  2  2  2  2  2  2
flower  |  0  0  0  2  5  5  5  5  7  7 (7) 7  7  7  7
                                         ↓
shovel  |  0  0  0  2  5  5  5  5  7  7  7*
```

그 다음은 이제 삽을 넣고 나면 1의 공간이 남는다. 1의 공간에 대한 최적해(`<a>`)는 이전 행에서 찾을 수 있으므로 이를 가져와 삽을 넣는 케이스와 합산(`<c>`)해 이전 이력(`<b>`)과 비교한다.

```text
bagSize |  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
book    |  0  0  0  2  2  2  2  2  2  2  2  2  2  2  2
flower  | (0) 0  0  2  5  5  5  5  7  7  7 (7) 7  7  7
            ↘<a>                 <c>      ↙<b>
              --------------→[ (0 + 6) VS 7 ]
                                           ↘<d>
shovel  |  0  0  0  2  5  5  5  5  7  7  7  7
```

동일한 과정을 거쳐 크기 14 까지는 모두 최대가격 7로 기록되게 된다.

shovel(크기:11)을 제외하고, 남은 공간은 4이다. 이전 행에서 최대가격은 2였으므로 이를 shovel 의 가격과 합산한다. 이번엔 이전 최대가격(7)보다 크다. 대체한다.

```text
bagSize |  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
book    |  0  0  0  2  2  2  2  2  2  2  2  2  2  2  2
flower  |  0  0  0 (2) 5  5  5  5  7  7  7  7  7  7 (7)
                     ↘<a>                <c>       ↙<b>
                      --------------→[ (2 + 6) VS 7 ]
                                                   ↘<d>
shovel  |  0  0  0  2  5  5  5  5  7  7  7  7  7  7  8
```

#### 물건이 하나 더 추가되었을 때

추가로 하게 되는 연산은 n 번이다. (가방의 크기에 대해서만 한 번 순회)
이전에 주먹구구식으로 풀었을 때 2번씩 곱해지던 것과는 많이 달라졌다.
